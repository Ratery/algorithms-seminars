// Copyright 2024 Vladislav Aleinik
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "utils.h"

//==================//
// Структура данных //
//==================//

// Представление типа узла связного списка
typedef struct Node {
    // Значение, хранящееся в связном списке
    // Здесь Data_t - это тип значения.
    // Этот тип должен быть задан непосредственно перед подключение заголовочного файла queue.h.
    Data_t value;

    // Указатель на следующий элемент списка
    struct Node* next;
    // Указатель на предыдущий элемент списка
    struct Node* prev;
} Node;

// Представление типа очереди
typedef struct {
    // Корневой узел кольцевого двусвязного списка.
    //
    // Инвариант структуры данных:
    // - Значение root.value никогда не используется.
    // - Значение root.next равно &root, если очередь пуста,
    //   в противном случае - root.next указывает на первый элемент в очереди.
    // - Значение root.prev равно &root, если очередь пуста,
    //   в противном случае - root.prev указывает на последний элемент в очереди.
    // - У последнего элемента непустого списка указатель next указывает на root.
    // - У первого элемента непустого списка указатель prev указывает на root.
    Node root;
} Queue;

//======================//
// Управление ресурсами //
//======================//

//==================================================================================================
// Функция: queue_alloc
// Назначение: Инициализирует очередь
//--------------------------------------------------------------------------------------------------
// Параметры:
// queue (in/out) - очередь, которую требуется инициализировать.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Для каждой очереди, инициализируемой с помощью queue_alloc,
//   должна быть вызвана функция queue_free.
//==================================================================================================
RetCode queue_alloc(Queue* queue)
{
    if (queue == NULL)
    {
        return RET_INVAL;
    }

    // Корневой узел кольцевого двусвязного списка
    Node* root = &queue->root;

    // Результат инициализации - пустая очередь.
    root->next = root;
    root->prev = root;

    return RET_OK;
}

//==================================================================================================
// Функция: queue_free
// Назначение: Освобождает ресурсы очереди
//--------------------------------------------------------------------------------------------------
// Параметры:
// queue (in/out) - очередь, ресурсы которой требуется освободить.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Для каждой очереди, освобождаемой с помощью queue_free,
//   должна ранее быть вызвана функция queue_alloc.
//==================================================================================================
RetCode queue_free(Queue* queue)
{
    if (queue == NULL)
    {
        return RET_INVAL;
    }

    // Корневой узел кольцевого двусвязного списка
    Node* root = &queue->root;

    // Первый узел в очереди
    Node* node = root->next;

    // Освобождаем память всех узлов связного списка
    while (node != root)
    {
        // Следующий узел связного списка
        Node* next = node->next;

        // Освобождаем память текущего узла
        free(node);

        // Переходим к следующему узлу
        node = next;
    }

    return RET_OK;
}

//====================================//
// Доступ к элементам связного списка //
//====================================//

//==================================================================================================
// Функция: queue_peek
// Назначение: Возвращает указатель на элемент, содержащийся в голове очереди.
//--------------------------------------------------------------------------------------------------
// Параметры:
// queue (in)  - очередь.
// data  (out) - указатель на память, в которую будет записан указатель на элемент,
//               содержащийся в голове очереди.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - При попытке доступа к голове пустой очереди будет возвращён код возврата RET_INVAL,
//   а по указателю data будет записано значение NULL.
//==================================================================================================
RetCode queue_peek(Queue* queue, Data_t** data)
{
    if (queue == NULL || data == NULL)
    {
        return RET_INVAL;
    }

    // Корневой узел кольцевого двусвязного списка
    Node* root = &queue->root;

    // Первый элемент связного списка
    Node* first = root->next;
    if (first == root)
    {   // Очередь пуста
        // Указатель на первый элемент не определён.
        *data = NULL;

        return RET_INVAL;
    }

    // Записываем указатель на первый элемент
    *data = &first->value;

    return RET_OK;
}

//==================================================================================================
// Функция: queue_add_tail
// Назначение: Записывает новый элемент в хвост очереди.
//--------------------------------------------------------------------------------------------------
// Параметры:
// queue (in/out) - очередь.
// data  (in)     - указатель на память, в которой содержится элемент,
//                  который будет записан в хвост очереди.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// отсутствуют
//==================================================================================================
RetCode queue_add_tail(Queue* queue, const Data_t* data)
{
    if (queue == NULL || data == NULL)
    {
        return RET_INVAL;
    }

    // Выделяем память нового узла
    Node* new = malloc(sizeof(Node));
    if (new == NULL)
    {
        return RET_NOMEM;
    }

    // Корневой узел кольцевого двусвязного списка
    Node* root = &queue->root;

    // Хвостовой узел кольцевого двусвязного списка
    Node* tail = root->prev;

    // Связываем новый узел с хвостовым и корневым узлами
    new->next = root;
    new->prev = tail;

    // Связываем корневой и хвостовой узлы с новым узлом
    root->prev = new;
    tail->next = new;

    // Записываем данные нового узла
    new->value = *data;

    return RET_OK;
}

//==================================================================================================
// Функция: queue_remove_head
// Назначение: Удаляет элемент из головы очереди.
//--------------------------------------------------------------------------------------------------
// Параметры:
// queue (in/out) - очередь.
// data  (out)    - указатель на память, в которую будет записан элемент,
//                  удаляемый из головы очереди.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// отсутствуют
//==================================================================================================
RetCode queue_remove_head(Queue* queue, Data_t* data)
{
    if (queue == NULL || data == NULL)
    {
        return RET_INVAL;
    }

    // Корневой узел кольцевого двусвязного списка
    Node* root = &queue->root;

    // Головной узел кольцевого двусвязного списка
    Node* head = root->next;

    if (head == root)
    {   // Очередь пуста
        // Удаление элемента из пустой очереди невозможно.
        return RET_INVAL;
    }

    // Удаляем голову из списка
    root->next = head->next;
    head->next->prev = root;

    // Сохраняем данных из головы списка
    *data = head->value;

    // Освобождаем память головного узла
    free(head);

    return RET_OK;
}

//==================================================================================================
// Функция: queue_empty
// Назначение: Возвращает флаг пустоты очереди 
//--------------------------------------------------------------------------------------------------
// Параметры:
// queue (in/out) - очередь.
//
// Возвращаемое значение:
// Флаг пустоты очереди.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// отсутствуют
//==================================================================================================
bool queue_empty(Queue* queue)
{
    if (queue == NULL)
    {
        return false;
    }

    // Корневой узел кольцевого двусвязного списка
    Node* root = &queue->root;

    // Головной узел кольцевого двусвязного списка
    Node* head = root->next;

    // Флаг пустоты очереди.
    return head == root;
}