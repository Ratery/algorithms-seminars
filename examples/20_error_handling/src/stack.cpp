// Copyright 2025 Vladislav Aleinik
#include <stack.hpp>
#include <utils.hpp>

#include <algorithm>
#include <stdexcept>

//---------------------------
// Конструкторы и деструктор
//---------------------------

//==================================================================================================
// Функция: Stack(StackResizePolicy)
// Назначение: инициализирует стек на основе стратегии реаллокации
//--------------------------------------------------------------------------------------------------
// Параметры:
// policy (in) - стратегия перевыделения памяти под элементы стека.
//
// Бросаемые исключения:
// std::bad_alloc - не хватает памяти.
//==================================================================================================
Stack::Stack(StackResizePolicy policy = RESIZE_SUM) :
    array_    (new Data_t[1]),
    size_     (0),
    capacity_ (1),
    policy_   (policy)
{}

//==================================================================================================
// Функция: Stack(std::initializer_list)
// Назначение: инициализирует стек на основе списка его будущих элементов
//--------------------------------------------------------------------------------------------------
// Параметры:
// list (in) - список объектов для заполнения стека.
//
// Бросаемые исключения:
// std::bad_alloc - не хватает памяти.
//==================================================================================================
Stack::Stack(std::initializer_list<Data_t> list) :
    policy_ (RESIZE_SUM)
{
    size_     = list.size();
    capacity_ = size_ + 1;
    array_    = new Data_t[capacity_];

    // Индекс для размещения объекта в массиве.
    size_t index = 0U;
    // Копируем элементы в массив.
    for (const auto& elem : list)
    {
        array_[index++] = elem;
    }
}

//==================================================================================================
// Функция: Stack(const Stack&)
// Назначение: инициализирует стек на основе списка его элементов
//--------------------------------------------------------------------------------------------------
// Параметры:
// that (in) - объект стека, на основе которого требуется инициализировать новый стек.
//
// Бросаемые исключения:
// std::bad_alloc - не хватает памяти.
//==================================================================================================
Stack::Stack(const Stack& that)
{
    // Параноидально проверяем предусловие.
    that.check();

    array_    = new Data_t[that.capacity_];
    size_     = that.size_;
    capacity_ = that.capacity_;
    policy_   = that.policy_;

    // Копируем все валидные элементы из массива.
    std::copy_n(that.array_, size_, array_);
}

Stack::Stack(Stack&& that) noexcept :
    array_    (that.array_),
    size_     (that.size_),
    capacity_ (that.capacity_),
    policy_   (that.policy_)
{
    that.array_    = nullptr;
    that.size_     = 0;
    that.capacity_ = 0;
}

Stack::~Stack() noexcept
{
    if (array_ != nullptr)
    {
        delete[] array_;
        size_     = 0;
        capacity_ = 0;
    }

    array_ = nullptr;
}

//-----------------------
// Оператор присваивания
//-----------------------

Stack& Stack::operator=(const Stack& that)
{
    Stack tmp(that);

    std::swap(*this, tmp);

    return *this;
}

Stack& Stack::operator=(Stack&& that) noexcept
{
    std::swap(array_,    that.array_);
    std::swap(size_,     that.size_);
    std::swap(capacity_, that.capacity_);
    std::swap(policy_,   that.policy_);

    return *this;
}

//---------------------------------
// Добавление и удаление элементов
//---------------------------------

//==================================================================================================
// Функция: Stack::push(const Data_t& data)
// Назначение: добавляет элемент на вершину стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// data (in) - элемент, который будет добавлен в стек.
//
// Бросаемые исключения:
// std::bad_alloc - не хватает памяти.
//==================================================================================================
Stack& Stack::push(const Data_t& data)
{
    // Параноидально проверяем предусловие.
    check();

    // Определяем необходимость увеличения ёмкости стека
    if (size_ == capacity_)
    {
        // Новая ёмкость стека
        size_t new_capacity = 0U;

        // Определяем новую ёмкость согласно стретегии реаллокации
        if (policy_ == RESIZE_SUM)
        {
            // Для стратегии RESIZE_SUM ёмкость стека увеличивается на 1 при каждом добавлении элемента
            new_capacity = capacity_ + 100U;
        }
        else
        {
            // Для стратегии RESIZE_MUL ёмкость стека увеличивается по степеням двойки
            new_capacity = (size_ == 0U)? 1U : (2U * capacity_);
        }

        // Производим перевыделение памяти
        resize(new_capacity);
    }

    // Добавляем элемент в стек
    array_[size_] = data;

    // Увеличиваем счётчик элементов в стеке
    size_ += 1U;

    return *this;
}

//==================================================================================================
// Функция: Stack::pop()
// Назначение: извлекает элемент с вершины стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// Отсутствуют.
//
// Бросаемые исключения:
// std::runtime_error - извлечение элемента из пустого стека невозможно.
// std::bad_alloc     - не хватает памяти.
//==================================================================================================
Data_t Stack::pop()
{
    // Параноидально проверяем предусловие.
    check();

    // Проверяем стек на пустоту
    if (size_ == 0U)
    {
        // Из пустого стека извлечение элемента невозможно
        throw std::runtime_error("Unable to pop from empty stack");
    }

    // Элемент, извлекаемый из стека.
    Data_t element = array_[size_ - 1U];

    // Производим перевыделение памяти согласно стретегии реаллокации
    if (policy_ == RESIZE_SUM)
    {
        // Уменьшаем счётчик элементов в стеке
        size_ -= 1U;

        // Для стратегии RESIZE_SUM ёмкость стека никогда не уменьшается
        return element;
    }

    // Для стратегии RESIZE_MUL ёмкость стека уменьшается экспоненциально с гистерезисом
    if (size_ - 1U > capacity_ / 4U)
    {
        // Уменьшаем счётчик элементов в стеке
        size_ -= 1U;

        return element;
    }

    // Новая ёмкость стека
    size_t new_capacity = (capacity_ <= 1U)? 1U : (capacity_ / 2U);

    if (new_capacity == capacity_)
    {
        // Уменьшаем счётчик элементов в стеке
        size_ -= 1U;

        return element;
    }

    // Обновление ёмкости стека
    resize(new_capacity);

    // Уменьшаем счётчик элементов в стеке
    size_ -= 1U;

    return element;
}

//==================================================================================================
// Функция: Stack::empty() const
// Назначение: извлекает элемент с вершины стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// Отсутствуют.
//
// Бросаемые исключения:
// Отсутствуют.
//==================================================================================================
bool Stack::empty() const noexcept
{
    return size_ == 0;
}

//------------------------
// Вспомогательные методы
//------------------------

//==================================================================================================
// Функция: Stack::check() const
// Назначение: Проверяет корректность текущего состояния стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// Отсутствуют.
//
// Бросаемые исключения:
// std::runtime_error - нарушен инвариант структуры данных.
//==================================================================================================
void Stack::check() const
{
    if (array_ == NULL)
    {
        throw std::runtime_error("Stack invariant broken: corrupt data");
    }

    if (capacity_ == 0)
    {
        throw std::runtime_error("Stack invariant broken: invalid capacity");
    }

    if (size_ > capacity_)
    {
        throw std::runtime_error("Stack invariant broken: invalid size and capacity");
    }
}

//==================================================================================================
// Функция: Stack::check() const
// Назначение: Меняет размер выделенной под стек памяти.
//--------------------------------------------------------------------------------------------------
// Параметры:
// new_capacity - новое значение ёмкости стека.
//
// Бросаемые исключения:
// std::bad_alloc - не хватает памяти.
//==================================================================================================
Stack& Stack::resize(size_t new_capacity)
{
    // Выделяем память под элементы стека.
    Data_t* new_array = new Data_t[new_capacity];

    // Вычисляем количество элементов в новом стеке
    size_t new_size = size_ < new_capacity? size_ : new_capacity;

    // Копируем данные в новый стек.
    std::copy_n(array_, new_size, new_array);

    delete[] array_;

    // Обновляем состояние стека
    array_    = new_array;
    size_     = new_size;
    capacity_ = new_capacity;

    return *this;
}
