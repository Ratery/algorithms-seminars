// Copyright 2024 Vladislav Aleinik
#ifndef HEADER_GUARD_EVIL_STACK_H_INCLUDED
#define HEADER_GUARD_EVIL_STACK_H_INCLUDED

#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>

#include "utils.h"

//==================//
// Структуры данных //
//==================//

// Стратегия реаллокации памяти при её нехватке
typedef enum
{
    // При нехватке памяти выделяется память под один дополнительный элемент
    RESIZE_SUM = 0,
    // При нехватке памяти полный объём памяти удваивается
    RESIZE_MUL = 1
} StackResizePolicy;

struct Stack
{
    // Массив с элементами стека
    data_t* array;

    // Количество элементов в стеке
    size_t size;

    // Размер выделенной памяти (кол-во элементов типа data_t)
    size_t capacity;

    // Стратегия перевыделения памяти при её нехватке
    StackResizePolicy policy;
};

// Тип данных, задающий код возврата
typedef enum
{
    // Операция выполнена без ошибок
    STACK_OK    = 0,
    // Операция не выполнена, т.к. в стеке нет элементов
    STACK_EMPTY = 1,
    // Операция не выполнена, т.к. для её выполнения не хватает памяти
    STACK_NOMEM = 2,
    // Операция не выполнена, т.к. аргументы операции некорректны
    STACK_INVAL = 3,
} StackRetCode;

//==================//
// Обработка ошибок //
//==================//

//==================================================================================================
// Функция: stack_ok
// Назначение: Проверяет корректность текущего состояния стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// stack (in/out) - стек, который требуется проверить.
//
// Возвращаемое значение:
// STACK_OK    - ошибок при проверке не выявлено.
// STACK_INVAL - текущее состояние стека некорректно.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Эта функция должна использоваться только в рамках текущего файла.
//==================================================================================================
StackRetCode stack_ok(struct Stack* stack)
{
    if (stack == NULL)
    {
        return STACK_INVAL;
    }

    if (stack->capacity == 0 || stack->array == NULL)
    {
        return STACK_INVAL;
    }

    if (stack->size > stack->capacity)
    {
        return STACK_INVAL;
    }

    if (stack->policy != RESIZE_SUM && stack->policy != RESIZE_MUL)
    {
        return STACK_INVAL;
    }

    return STACK_OK;
}

//==================================================================================================
// Функция: stack_retcode_str
// Назначение: Возвращает строку, соответствующую коду ошибки
//--------------------------------------------------------------------------------------------------
// Параметры:
// code (in) - стек, который требуется проверить.
//
// Возвращаемое значение:
// Строка, соответствующая коду возврата code.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// отсутствуют
//==================================================================================================
const char* stack_retcode_str(StackRetCode code)
{
    switch (code)
    {
        case STACK_OK:
        {
            return "stack is ok";
        }
        case STACK_EMPTY:
        {
            return "stack is empty";
        }
        case STACK_NOMEM:
        {
            return "not enough memory";
        }
        case STACK_INVAL:
        {
            return "invalid argument";
        }
        default:
        {
            return "invalid return code";
        }
    }
}

//======================//
// Управление ресурсами //
//======================//

//==================================================================================================
// Функция: stack_init
// Назначение: инициализирует стек
//--------------------------------------------------------------------------------------------------
// Параметры:
// stack (in/out) - стек, который требуется инициализировать.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Для каждого стека, инициализируемого с помощью stack_init,
//   должна быть вызвана функция stack_free.
//==================================================================================================
StackRetCode stack_init(struct Stack* stack, StackResizePolicy policy)
{
    if (stack == NULL || (policy != RESIZE_SUM && policy != RESIZE_MUL))
    {
        return STACK_INVAL;
    }

    // Инициализируем поля структуры
    stack->size     = 0U;
    stack->capacity = 1U;
    stack->policy   = policy;

    // Аллоцируем память под один элемент массива
    stack->array = malloc(1U * sizeof(data_t));
    if (stack->array == NULL)
    {
        return STACK_NOMEM;
    }

    return STACK_OK;
}

//==================================================================================================
// Функция: stack_free
// Назначение: освобождает ресурсы стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// stack (in/out) - стек, ресурсы которого требуется освободить.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Для каждого стека, освобождаемого с помощью stack_free,
//   должна быть вызвана функция stack_init.
//==================================================================================================
StackRetCode stack_free(struct Stack* stack)
{
    // Проверяем состояние стека
    StackRetCode ret = stack_ok(stack);
    if (ret != STACK_OK)
    {
        return ret;
    }

    // Освобождаем ресурсы стека
    free(stack->array);

    // Вводим стек в заведомо некорректное состояние
    stack->array    = NULL;
    stack->capacity = 0U;
    stack->size     = 0U;

    return STACK_OK;
}


//==================================================================================================
// Функция: stack_resize
// Назначение: Меняет размер выделенной под стек памяти
//--------------------------------------------------------------------------------------------------
// Параметры:
// stack (in/out) - стек, ёмкость которого требуется изменить.
// new_capacity   - новое значение ёмкости стека.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Эта функция должна использоваться только в рамках текущего файла.
//==================================================================================================
StackRetCode stack_resize(struct Stack* stack, size_t new_capacity)
{
    // Проверяем состояние стека
    StackRetCode ret = stack_ok(stack);
    if (ret != STACK_OK)
    {
        return ret;
    }

    // Перевыделяем память под элементы стека
    data_t* new_array = realloc(stack->array, new_capacity * sizeof(data_t));
    if (new_array == NULL)
    {
        return STACK_NOMEM;
    }


    // Вычисляем количество элементов в новом стеке
    size_t new_size = MIN(stack->size, new_capacity);

    // Обновляем состояние стека
    stack->array    = new_array;
    stack->size     = new_size;
    stack->capacity = new_capacity;

    return STACK_OK;
}

//=====================//
// Операции над стеком //
//=====================//

//==================================================================================================
// Функция: stack_push
// Назначение: добавляет элемент на вершину стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// stack (in/out) - стек, в который будет добавлен элемент.
// element (in)   - элемент, который будет добавлен в стек.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Стек предварительно должен быть инициализирован с помощью stack_init
//==================================================================================================
StackRetCode stack_push(struct Stack* stack, data_t element)
{
    // Проверяем состояние стека
    StackRetCode ret = stack_ok(stack);
    if (ret != STACK_OK)
    {
        return ret;
    }

    // Определяем необходимость увеличения ёмкости стека
    if (stack->size == stack->capacity)
    {
        // Новая ёмкость стека
        size_t new_capacity = 0U;

        // Определяем новую ёмкость согласно стретегии реаллокации
        if (stack->policy == RESIZE_SUM)
        {
            // Для стратегии RESIZE_SUM ёмкость стека увеличивается на 1 при каждом добавлении элемента
            new_capacity = stack->capacity + 1U;
        }
        else
        {
            // Для стратегии RESIZE_MUL ёмкость стека увеличивается по степеням двойки
            new_capacity = (stack->size == 0U)? 1U : (2U * stack->capacity);
        }

        // Производим перевыделение памяти
        ret = stack_resize(stack, new_capacity);
        if (ret != STACK_OK)
        {
            return ret;
        }
    }

    // Добавляем элемент в стек
    stack->array[stack->size] = element;

    // Увеличиваем счётчик элементов в стеке
    stack->size += 1U;

    return STACK_OK;
}

//==================================================================================================
// Функция: stack_pop
// Назначение: извлекает элемент с вершины стека
//--------------------------------------------------------------------------------------------------
// Параметры:
// stack (in/out) - стек, из которого будет извлечён элемент.
// element (in)   - элемент, который будет извлечён из стека.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Стек предварительно должен быть инициализирован с помощью stack_init.
//==================================================================================================
StackRetCode stack_pop(struct Stack* stack, data_t* element)
{
    // Проверяем состояние стека
    StackRetCode ret = stack_ok(stack);
    if (ret != STACK_OK)
    {
        return ret;
    }

    // Проверяем стек на пустоту
    if (stack->size == 0U)
    {
        // Из пустого стека извлечение элемента невозможно
        return STACK_EMPTY;
    }

    // Записываем элемент в указатель от пользователя
    *element = stack->array[stack->size - 1U];

    // Уменьшаем счётчик элементов в стеке
    stack->size -= 1U;

    // Производим перевыделение памяти согласно стретегии реаллокации
    if (stack->policy == RESIZE_SUM)
    {
        // Для стратегии RESIZE_SUM ёмкость стека никогда не уменьшается
        return STACK_OK;
    }

    // Для стратегии RESIZE_MUL ёмкость стека уменьшается экспоненциально с гистерезисом
    if (stack->size > stack->capacity / 4U)
    {
        return STACK_OK;
    }

    // Новая ёмкость стека
    size_t new_capacity = (stack->capacity <= 1U)? 1U : (stack->capacity / 2U);

    if (new_capacity == stack->capacity)
    {
        return STACK_OK;
    }

    // Обновление ёмкости стека
    ret = stack_resize(stack, new_capacity);
    return ret;
}

#endif // HEADER_GUARD_EVIL_STACK_H_INCLUDED
