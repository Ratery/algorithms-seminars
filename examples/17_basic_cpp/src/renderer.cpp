// Copyright 2025 Vladislav Aleinik
#include <renderer.hpp>

//======================//
// Управление ресурсами //
//======================//

//==================================================================================================
// Функция: Renderer::init
// Назначение: Инициализирует объект-отрисовщик.
//--------------------------------------------------------------------------------------------------
// Параметры:
// size_x      (in) - ширина окна отрисовки.
// size_y      (in) - высота окна отрисовки.
// window_name (in) - имя окна отрисовки.
//
// Возвращаемое значение:
// Отсутствует.
//
// Используемые внешние переменные:
// Отсутствуют.
//
// Примечания:
// - Для каждого объект-отрисовщик, инициализируемого с помощью Renderer::init,
//   должна быть вызвана функция Renderer::destroy.
//==================================================================================================
RetCode Renderer::init(size_t size_x, size_t size_y, const char* window_name)
{
    // Инициализируем размеры окна.
    size_x_ = size_x;
    size_y_ = size_y;

    // Создаём дисплей X11.
    display_ = XOpenDisplay(nullptr);
    if (display_ == nullptr)
    {
        return RetCode::RET_SYSTEM_CONFIG_ERROR;
        // throw std::system_error("Renderer(): unable to create display object");
    }

    // Создаём новое окно X11.
    window_ = XCreateSimpleWindow(
        display_,                     // Специфицируем соединение с X11-сервером.
        XDefaultRootWindow(display_), // Родительское окно - корневое.
        0, 0,                         // Размещаем окно в левом верхнем углу.
        size_x,                       // Выставляем размеры окна: ширину и высоту.
        size_y,
        0,                            // Ширина границы: 0
        0,                            // Цвет границы: 0 (чёрный)
        0);                           // Цвет фона: 0 (чёрный)

    // Проверяем наличие расширения Xdbe.
    // Примечание: DBE (Double Buffering Extension) предоставляет интерефейс
    // к аппаратной двойной буферизации через интерфейс DRM ОС Linux.
    int major_version_return, minor_version_return;
    bool ret = XdbeQueryExtension(display_, &major_version_return, &minor_version_return);
    if (ret == false)
    {
        return RetCode::RET_SYSTEM_CONFIG_ERROR;
        // throw std::system_error("Renderer(): XDBE X11 extension is reqired and missing");
    }

    // Инициализируем графический контекст.
    gc_ = XCreateGC(display_, window_, 0, nullptr);

    // Создаём дополнительный фреймбуфер ("back buffer").
    back_buffer_ = XdbeAllocateBackBufferName(display_, window_, 0);

    // Выставляем имя окна.
    XStoreName(display_, window_, window_name);

    // Создаём действие (протокол) для закрытия окна:
    wm_delete_window_ = XInternAtom(display_, "WM_DELETE_WINDOW", False);

    // Передаём в оконный менеджер список действий (протоколов), которые клиент буфет исполнять:
    // - WM_DELETE_WINDOW - действие "закрыть окно".
    XSetWMProtocols(display_, window_, &wm_delete_window_, 1);

    // Выставляем маску интересующих клиента событий, за которыми должен следить сервер.
    // Единственное интересное событие - KeyPressMask (нажатия на кнопки).
    XSelectInput(display_, window_, KeyPressMask);

    // Устанавливаем ассоциацию дисплея и окна.
    XMapWindow(display_, window_);

    return RetCode::RET_OK;
}

//==================================================================================================
// Функция: Renderer::destroy
// Назначение: Освобождает ресурсы объекта-отрисовщика.
//--------------------------------------------------------------------------------------------------
// Параметры:
// Отсутствуют.
//
// Возвращаемое значение:
// Отсутствует.
//
// Используемые внешние переменные:
// Отсутствуют.
//
// Примечания:
// - Для каждого объекта-отрисовщика, освобождаемого с помощью Renderer::destroy,
//   ранее должна была быть вызвана функция Renderer::init.
//==================================================================================================
void Renderer::destroy()
{
    if (display_ != nullptr)
    {
        // Закрываем соединение с сервером X11.
        // Примечание: вызов этой функции фактически освобождает все ресуры,
        // ассоциированные с дисплеем.
        XCloseDisplay(display_);

        display_ = nullptr;
    }
}

//===================//
// Обработка событий //
//===================//

//==================================================================================================
// Функция: Renderer::events_pending
// Назначение: Возвращает флаг наличия событий для обработки.
//==================================================================================================
bool Renderer::events_pending()
{
    return XPending(display_) > 0;
}

//==================================================================================================
// Функция: Renderer::next_event
// Назначение: Возвращает следующее необработанное событие.
//==================================================================================================
XEvent Renderer::next_event()
{
    XEvent event;
    XNextEvent(display_, &event);

    return event;
}

//==================================================================================================
// Функция: Renderer::event_delete_window
// Назначение: Возвращает событие, исполняемое по выходу из окна.
//==================================================================================================
const Atom& Renderer::event_delete_window()
{
    return wm_delete_window_;
}

//=====================//
// Примитивы отрисовки //
//=====================//

//==================================================================================================
// Функция: Renderer::clear_screen
// Назначение: Очищает экран.
//==================================================================================================
Renderer& Renderer::clear_screen()
{
    // Устанваливаем цвет отрисовки.
    XSetForeground(display_, gc_, 0);

    // Используя дополнительный фреймбуфер для отрисовки, закрашивам всё окно.
    XFillRectangle(display_, back_buffer_, gc_, 0, 0, size_x_, size_y_);

    return *this;
}

//==================================================================================================
// Функция: Renderer::set_pixel
// Назначение: Выставляет пиксель на экран.
//--------------------------------------------------------------------------------------------------
// Параметры:
// x     (in) - X-координата пикселя.
// y     (in) - Y-координата пикселя.
// color (in) - RGB-представление цвета.
//
// Возвращаемое значение:
// Отсутствует.
//
// Используемые внешние переменные:
// Отсутствуют.
//
// Примечания:
// - Пиксель, находящийся за пределами экрана, не отрисовывается.
//==================================================================================================
Renderer& Renderer::set_pixel(size_t x, size_t y, uint32_t color)
{
    if (x >= size_x_ || y >= size_y_)
    {
        return *this;
    }

    // Устанавливаем цвет отрисовки.
    XSetForeground(display_, gc_, color);

    // Используя дополнительный фреймбуфер для отрисовки, выставляем пиксель.
    XDrawPoint(display_, back_buffer_, gc_, x, y);

    return *this;
}

//==================================================================================================
// Функция: Renderer::do_render
// Назначение: Отрисовывает содержимое буфера на экране.
//==================================================================================================
Renderer& Renderer::do_render()
{
    XdbeSwapInfo swap_info;
    swap_info.swap_window = window_;
    swap_info.swap_action = 0;

    // Меняем местами основной буфер и дополнительный.
    XdbeSwapBuffers(display_, &swap_info, 1);

    return *this;
}
