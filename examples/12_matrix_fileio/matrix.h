// Copyright 2024 Vladislav Aleinik
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "utils.h"

//==================//
// Структура данных //
//==================//

// Представление двумерной матрицы
struct Matrix
{
    // Думерный массив элементов матрицы
    double** data;
    // Количество столбцов
    size_t size_x;
    // Количество строк
    size_t size_y;
};

//======================//
// Управление ресурсами //
//======================//

//==================================================================================================
// Функция: matrix_alloc
// Назначение: Инициализирует матрицы
//--------------------------------------------------------------------------------------------------
// Параметры:
// mat (in/out) - матрица, которую требуется инициализировать.
// size_x (in)  - количество столбцов.
// size_y (in)  - количество строк.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Для каждой матрицы, инициализируемой с помощью matrix_alloc,
//   должна быть вызвана функция matrix_free.
//==================================================================================================
RetCode matrix_alloc(struct Matrix* mat, size_t size_x, size_t size_y)
{
    if (mat == NULL)
    {
        return RET_INVAL;
    }

    // Выделяем массив, содержащий строки матрицы
    double** data = (double**) calloc(size_y, sizeof(double*));
    if (data == NULL)
    {
        return RET_NOMEM;
    }

    // Выделяем строки матрицы
    for (size_t y = 0U; y < size_y; ++y)
    {
        data[y] = (double*) calloc(size_x, sizeof(double));
        if (data[y] == NULL)
        {
            return RET_NOMEM;
        }
    }

    mat->data = data;
    mat->size_y = size_y;
    mat->size_x = size_x;

    return RET_OK;
}

//==================================================================================================
// Функция: matrix_free
// Назначение: Освобождает ресурсы, выделенные под матрицу
//--------------------------------------------------------------------------------------------------
// Параметры:
// mat (in/out) - матрица, ресурсы которой требуется освободить.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Для каждой матрицы, освобождамой с помощью matrix_free,
//   ранее должна быть вызвана функция matrix_alloc.
//==================================================================================================
RetCode matrix_free(struct Matrix* mat)
{
    if (mat == NULL || mat->data == NULL)
    {
        return RET_INVAL;
    }

    // Освобождаем строки матрицы
    for (size_t y = 0U; y < mat->size_y; ++y)
    {
        if (mat->data[y] == NULL)
        {
            return RET_INVAL;
        }

        free(mat->data[y]);
    }

    // Освобождаем массив строк
    free(mat->data);

    // Зануляем указатель, чтобы защититься от повторного вызова matrix_free.
    mat->data = NULL;

    return RET_OK;
}

//============================//
// Доступ к элементам матрицы //
//============================//

//==================================================================================================
// Функция: matrix_get
// Назначение: Возвращает элемент матрицы по паре индексов.
//--------------------------------------------------------------------------------------------------
// Параметры:
// mat (in/out)  - матрица, элемент которой будет извлечён.
// y (in)        - номер строки.
// x (in)        - номер столбца.
// element (out) - указатель, по которому будет записан извлечённый элемент.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Доступ по индексам за границами матрицы запрещён.
//==================================================================================================
RetCode matrix_get(const struct Matrix* mat, size_t y, size_t x, double* element)
{
    if (mat == NULL      || mat->data    == NULL ||
        y >= mat->size_y || mat->data[y] == NULL || x >= mat->size_x)
    {
        return RET_INVAL;
    }

    *element = mat->data[y][x];

    return RET_OK;
}

//==================================================================================================
// Функция: matrix_set
// Назначение: Перезаписывает элемент матрицы по паре индексов.
//--------------------------------------------------------------------------------------------------
// Параметры:
// mat (in/out) - матрица, элемент которой будет перезаписан.
// y (in)       - номер строки.
// x (in)       - номер столбца.
// element (in) - элемент, который будет перезаписан.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Доступ по индексам за границами матрицы запрещён.
//==================================================================================================
RetCode matrix_set(const struct Matrix* mat, size_t y, size_t x, double element)
{
    if (mat == NULL      || mat->data    == NULL ||
        y >= mat->size_y || mat->data[y] == NULL || x >= mat->size_x)
    {
        return RET_INVAL;
    }

    mat->data[y][x] = element;

    return RET_OK;
}

//=================================//
// Чтение из файла и запись в файл //
//=================================//

//==================================================================================================
// Функция: matrix_scan_from_file
// Назначение: Считывает матрицу из файла
//--------------------------------------------------------------------------------------------------
// Параметры:
// filename (in) - имя файла, на основе которого будет создана матрица.
// mat (out)     - матрица, создаваемая на основе файла.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Файл по пути filename должен существовать в файловой системе.
//==================================================================================================
RetCode matrix_scan_from_file(const char* filename, struct Matrix* mat)
{
    if (filename == NULL || mat == NULL)
    {
        return RET_INVAL;
    }

    // Указатель на управляющую структуру файла
    FILE* file;

    // Открываем файл
    file = fopen(filename, "r");
    if (file == NULL)
    {
        // При открытии файла произошла ошибка
        return RET_INVAL;
    }

    // Количество строк и столбцов в матрице
    size_t size_y = 0U, size_x = 0U;

    // Считываем размеры матрицы из файла
    int ret = fscanf(file, "%zu %zu\n", &size_y, &size_x);
    if (ret != 2)
    {
        // При чтении файла произошла ошибка
        fclose(file);
        return RET_FILEIO;
    }

    // Аллоцируем матрицу необходимого размера
    struct Matrix tmp;
    RetCode mret = matrix_alloc(&tmp, size_x, size_y);
    if (mret != RET_OK)
    {
        fclose(file);
        return mret;
    }

    // Инициализируем матрицу
    for (size_t y = 0U; y < size_y; ++y)
    {
        for (size_t x = 0U; x < size_x; ++x)
        {
            double element = 0.0;
            int ret = fscanf(file, "%lf[ \n]", &element);
            if (ret != 1)
            {
                // Перед выходом освобождаем ресурсы
                matrix_free(&tmp);
                fclose(file);
                return RET_FILEIO;
            }

            // В целях оптимизации делаем прямую запись, а не вызов matrix_set
            tmp.data[y][x] = element;
        }
    }

    tmp.size_y = size_y;
    tmp.size_x = size_x;

    // Закрываем открытый файл
    ret = fclose(file);
    if (ret == EOF)
    {
        matrix_free(&tmp);
        return RET_FILEIO;
    }

    // Записываем результат только при успешном выполнении
    *mat = tmp;

    return RET_OK;
}

//==================================================================================================
// Функция: matrix_dump_to_file
// Назначение: Записывает матрицу в файл
//--------------------------------------------------------------------------------------------------
// Параметры:
// filename (in) - имя файла, в который будет записана матрица.
// mat (out)     - матрица, которая будет записана в файл.
//
// Возвращаемое значение:
// Код возврата.
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// - Файл по пути filename будет переписан или создан в файловой системе.
//==================================================================================================
RetCode matrix_dump_to_file(const char* filename, const struct Matrix* mat)
{
    if (filename == NULL || mat == NULL)
    {
        return RET_INVAL;
    }

    // Указатель на управляющую структуру файла
    FILE* file;

    // Открываем файл
    file = fopen(filename, "w");
    if (file == NULL)
    {
        // При открытии файла произошла ошибка
        return RET_INVAL;
    }

    // Записываем размеры матрицы в файл
    int ret = fprintf(file, "%zu %zu\n", mat->size_y, mat->size_x);
    if (ret <= 0)
    {
        fclose(file);
        return RET_FILEIO;
    }

    // Записываем элементы матрицы в файл
    for (size_t y = 0U; y < mat->size_y; ++y)
    {
        for (size_t x = 0U; x < mat->size_x; ++x)
        {
            double element;
            RetCode mret = matrix_get(mat, y, x, &element);
            if (mret != RET_OK)
            {
                fclose(file);
                return mret;
            }

            // Разделитель (пробел или перенос строки)
            char delimiter;
            if (x + 1 == mat->size_x)
            {
                delimiter = '\n';
            }
            else
            {
                delimiter = ' ';
            }

            // Записываем элемент в файл
            int ret = fprintf(file, "%lf%c", element, delimiter);
            if (ret <= 0)
            {
                // Перед выходом закрываем открытый файл
                fclose(file);
                return RET_FILEIO;
            }
        }
    }

    // Закрываем открытый файл
    ret = fclose(file);
    if (ret == EOF)
    {
        return RET_FILEIO;
    }

    return RET_OK;
}

//========================//
// Операции над матрицами //
//========================//

//==================================================================================================
// Функция: matrix_equal
// Назначение: производит сравнение двух матриц
//--------------------------------------------------------------------------------------------------
// Параметры:
// mat1 (in) - первая матрица.
// mat2 (in) - вторая матрица.
// ret (out) - Флаг равенства матриц в пределах погрешности (по непрерывной метрике)
//
// Возвращаемое значение:
// Код возврата
//
// Используемые внешние переменные:
// отсутствуют
//
// Примечания:
// отсутствуют
//==================================================================================================
RetCode matrix_equal(const struct Matrix* mat1, const struct Matrix* mat2, bool* ret)
{
    if (ret == NULL || mat1 == NULL || mat2 == NULL || mat1->data == NULL || mat2->data == NULL)
    {
        return RET_INVAL;
    }

    // Матрица равна самой себе
    if (mat1 == mat2)
    {
        *ret = true;
        return RET_OK;
    }

    // Матрицы разных размеров не могут быть равны
    if (mat1->size_x != mat2->size_x ||
        mat1->size_y != mat2->size_y)
    {
        *ret = false;
        return RET_OK;
    }

    // Для равенства по непрерывной метрике все элементы матрицы должны быть равны
    for (size_t y = 0U; y < mat1->size_y; ++y)
    {
        for (size_t x = 0U; x < mat1->size_x; ++x)
        {
            RetCode mret;
            double el1;
            mret = matrix_get(mat1, y, x, &el1);
            if (mret != RET_OK)
            {
                return mret;
            }

            double el2;
            mret = matrix_get(mat2, y, x, &el2);
            if (mret != RET_OK)
            {
                return mret;
            }

            if (!double_equal(el1, el2))
            {
                *ret = false;
                return RET_OK;
            }
        }
    }

    *ret = true;
    return RET_OK;
}
