// No copyright. Vladislav Alenik, 2024
#include <vector.hpp>

#include <cassert>
#include <cstring>
#include <cmath>
#include <algorithm>

// NOTE: use namespace to make Vector visible.
using namespace VectorArithmetics;

//----------------------
// Existance management
//----------------------

// Constructor (non-default):
Vector::Vector(size_t size) :
    data_ (new double[size]),
    size_ (size)
{
    // NOTE: new throws exception std::bad_alloc on allocation error.

    // NOTE: be paranoid, ensure the invariant is established.
    VERIFY_CONTRACT(this->ok(),
        "Unable to construct Vector instance");
}

// Copy constructor:
// NOTE: the rule of three (1/3)
// NOTE: the rule of five (1/5)
Vector::Vector(const Vector& vector)
{
    VERIFY_CONTRACT(vector.ok(),
        "Unable to create Vector from invalid origin");

    // Allocate new array and perform deep copy:
    data_ = new double[vector.size_];
    size_ = vector.size_;

    std::copy_n(vector.data_, size_, data_);

    // NOTE: be paranoid, ensure the invariant is established.
    VERIFY_CONTRACT(this->ok(),
        "Unable to construct Vector instance");
}

// Move constructor:
// NOTE: the rule of five (2/5)
Vector::Vector(Vector&& vector)
{
    VERIFY_CONTRACT(vector.ok(),
        "Unable to create Vector from invalid origin");

    // Perform the shallow assignment:
    data_ = vector.data_;
    size_ = vector.size_;

    // Make move origin invalid:
    vector.data_ = nullptr;
    vector.size_ = 0U;

    // NOTE: be paranoid, ensure the invariant is established.
    VERIFY_CONTRACT(this->ok(),
        "Unable to construct Vector instance");
    // NOTE: be paranoid, ensure the invariant no longer holds for move origin.
    VERIFY_CONTRACT(!vector.ok(),
        "Move operation is non-destructive for move origin");
}

// Copy assignment:
// NOTE: the rule of three (2/3)
// NOTE: the rule of five (3/5)
Vector& Vector::operator=(const Vector& vector)
{
    VERIFY_CONTRACT(this->ok(),
        "Left operand of copy assignment is invalid");
    VERIFY_CONTRACT(vector.ok(),
        "Right operand of copy assignment is invalid");

    // Check the case of self-assignment:
    if (this == &vector)
    {
        return *this;
    }

    // Deallocate previously allocated memory:
    delete[] data_;

    // Allocate new array and perform deep copy:
    data_ = new double[vector.size_];
    size_ = vector.size_;

    std::copy_n(vector.data_, size_, data_);

    // NOTE: be paranoid, ensure the invariant still holds.
    VERIFY_CONTRACT(this->ok(),
        "Unable to perform copy assignment");

    return *this;
}

// Move assignment:
// NOTE: the rule of five (4/5)
Vector& Vector::operator=(Vector&& vector)
{
    VERIFY_CONTRACT(this->ok(),
        "Left operand of move assignment is invalid");
    VERIFY_CONTRACT(vector.ok(),
        "Right operand of move assignment is invalid");
    VERIFY_CONTRACT(this != &vector,
        "Move assignment from itself must not be generated by compiler");

    // Deallocate previously allocated memory:
    delete[] data_;

    // Perform shallow copy:
    data_ = vector.data_;
    size_ = vector.size_;

    // Make move origin invalid:
    vector.data_ = nullptr;
    vector.size_ = 0U;

    // NOTE: be paranoid, ensure the invariant still holds.
    VERIFY_CONTRACT(this->ok(),
        "Unable to perform move assignment");
    // NOTE: be paranoid, ensure the invariant no longer holds for move origin.
    VERIFY_CONTRACT(!vector.ok(),
        "Move operation is non-destructive for move origin");

    return *this;
}

// Destructor:
// NOTE: the rule of three (3/3)
// NOTE: the rule of five (5/5)
Vector::~Vector()
{
    if (data_ != nullptr)
    {
        delete[] data_;
    }

    // Set vector data to NULL to detect double free:
    data_ = nullptr;
}

//------------------
// Getter && setter
//------------------

size_t Vector::size() const
{
    VERIFY_CONTRACT(this->ok(),
        "Invalid vector data (possible double free)");

    return size_;
}

Vector& Vector::setSize(size_t new_size)
{
    VERIFY_CONTRACT(this->ok(),
        "Invalid vector data (possible double free)");

    if (new_size == size_)
    {
        return *this;
    }

    // NOTE: new throws exception std::bad_alloc on allocation error.
    double* new_data = new double[new_size];

    std::copy_n(new_data, std::min(new_size, size_), data_);

    // Unallocate old allocated data:
    delete[] data_;

    // Update data internal variables:
    data_ = new_data;
    size_ = new_size;

    // NOTE: be paranoid, ensure the invariant still holds.
    VERIFY_CONTRACT(this->ok(),
        "Unable to set size");

    return *this;
}


//----------------
// Element access
//----------------

double& Vector::operator[](const size_t index)
{
    VERIFY_CONTRACT(this->ok(),
        "Invalid vector data (possible double free)");
    VERIFY_CONTRACT(index < size_,
        "Index %zu out of bounds (size is %zu)",
        index, size_);

    return data_[index];
}

//-----------------------
// Arithmetic operations
//-----------------------

Vector Vector::operator+(const Vector& other) const
{
    // Copy-construct the vector as a copy of *this:
    Vector to_return{*this};

    // NOTE: the implemenation of += performs all correctness checks.
    to_return += other;

    // NOTE: there is no actual copying in return statement thanks to:
    //       RVO (Return Value Optimization) and NRVO (Named RVO).
    return to_return;
}

Vector& Vector::operator+=(const Vector& other)
{
    VERIFY_CONTRACT(this->ok(),
        "Invalid vector data (possible double free for left argument)");
    VERIFY_CONTRACT(other.ok(),
        "Invalid vector data (possible double free for right argument)");
    VERIFY_CONTRACT(size_ == other.size_,
        "Unmatched operand sizes (%zu and %zu)",
        size_, other.size_);

    for (size_t i = 0U; i < size_; ++i)
    {
        data_[i] += other.data_[i];
    }

    return *this;
}

//-------------
// Comparisons
//-------------

bool Vector::operator==(const Vector& other) const
{
    VERIFY_CONTRACT(this->ok(),
        "Invalid vector data (possible double free for left argument)");
    VERIFY_CONTRACT(other.ok(),
        "Invalid vector data (possible double free for right argument)");

    // Case of identical equality:
    if (this == &other)
    {
        return true;
    }

    if (size_ != other.size_)
    {
        return false;
    }

    for (size_t i = 0U; i < size_; ++i)
    {
        if (!double_equal(data_[i], other.data_[i]))
        {
            return false;
        }
    }

    return true;
}

bool Vector::operator!=(const Vector& other) const
{
    return !(*this == other);
}

//-----------------
// Helper function
//-----------------

constexpr double DOUBLE_PRECISION = 10e-9;

// NOTE: never (N.E.V.E.R.) overload operators of arithmetic types.
// PRANK TIP: you can do it somewhere in yor friend's code
//            and observe his/her frustration over it (0__0).
bool Vector::double_equal(double el1, double el2)
{
    return std::fabs(el1 - el2) < DOUBLE_PRECISION;
}

//------------------------------------
// Verification of internal invariant
//------------------------------------

bool Vector::ok() const
{
    // The only internal invariant -- data_ is non-null.
    return data_ != nullptr;
}
