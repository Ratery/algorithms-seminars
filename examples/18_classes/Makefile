# Copyright 2025 Vladislav Aleinik

# Как пользоваться данным шаблоном Makefile:
# 1. Запишите список своих файлов реализации в переменную SOURCES.
# 2. Запишите список своих заголовочных файлов в переменную INCLUDES.
# 3. Запишите название своего исполняемого файла в переменную EXECUTABLE.
# 4. Соберите свою программу с помощью команды консоли "make".
# 5. При необходимости работы с отладчиком соберите бинарник с помощью команды "make DEBUG=1".
# 6. Запустите вашу программу с помощью команды "make run".
# 7. Очистите результат сборки и исполнения с помощью команды "make clean".

# Вопросы к сдаче ДЗ:
# 1. Как сделать так, чтобы добавление нового файла реализации не требовало переписывания Makefile-а?
# 2. Как сделать так, чтобы файл реализации зависел только от тех заголовочных файлов, которые он подключает?
# 3. Как сделать так, чтобы при обновлении флагов сборки в этом Makefile-е происходила полная пересборка проекта?

#-------------------------
# Флаги сборки и линковки
#-------------------------

# Название бинарного файла компилятора.
# Проверить наличие того или иного компилятора можно, набрав в командной строке:
# <compiler> --help
# или
# <compiler> --version
CXX = g++

# Флаги сборки:
# -std=c++17 - задание версии стандарта C++.
# -Wall      - включение всех основных предупреждений компилятора.
# -Wextra    - вклчение дополнительных предупреждений компилятора.
# -Werror    - по включении данного флага компиляции каждое предупреждение
#              считается ошибкой и останавливает процесс компиляции.
CXXFLAGS =     \
	-std=c++17 \
	-Wall      \
	-Wextra    \
	-Werror

# Флаги линковки.
# Обычно они нужны для связывания со сторониими библиотеками.
# В данном примере они не используются, но для некоторых частей стандартной
# библиотеки необходимо добавлять дополнительный флаг линковки:
# -lm - флаг для линковки математической библиотеки.
LDFLAGS =

# Выбираем режим сборки.
# Для выбора режима сборки нужно запускать make, выставляя при этом переменную окружения.
# DEBUG=1 make
# или
# make DEBUG=1
ifeq ($(DEBUG),1)
	# Флаг компилятора -g добавляет отладочную информацию, которую использует отладчик.
	CXXFLAGS += -g
else
	# Флаг сборки/линковки -flto включаем оптимизации времени линковки (LTO = Link-Time Optimization)
	# Флаг -D<имя макроса> задаёт новое макроопределение.
	# Конкретно макрос NDEBUG - особенный, он убирает все самопроверки assert.
	CXXFLAGS  += -flto -DNDEBUG
	LXXDFLAGS += -flto
endif

#-------
# Цвета
#-------

# Задаём константы для кодов цветов ANSI.
# Предположительно, не любая консоль понимает эти коды.
BRED    = \033[1;31m
BGREEN  = \033[1;32m
BYELLOW = \033[1;33m
GREEN   = \033[1;35m
BCYAN   = \033[1;36m
RESET   = \033[0m

#-------
# Файлы
#-------

# Явно заданный список заголовочных файлов.
INCLUDES = \
	include/utils.hpp \
	include/vector.hpp

# Добавляем директорию include в качестве дополнительной директории для поиска заголовочных файлов.
CXXFLAGS += -I $(abspath include)

# Список файлов реализации.
SOURCES = \
	src/test.cpp \
	src/utils.cpp \
	src/vector.cpp

# Составляем список объектных файлов.
# Например, файлу реализации src/test.cpp будет соответствовать объектный файл build/test.o.
OBJECTS = $(SOURCES:src/%.cpp=build/%.o)

# Исполняемый файл.
EXECUTABLE = build/test

#----------------
# Процесс сборки
#----------------

# По умолчанию, собираем исполняемый файл.
# Примечание: самая верхняя цель сборки в файле является целью по умолчанию.
default: $(EXECUTABLE)

# Линкуем все объектные файлы вместе для получения исполняемого файла.
# Примечание: до этого все будут собраны объектные файлы.
$(EXECUTABLE): $(OBJECTS)
	@printf "$(BYELLOW)Linking executable $(BCYAN)$@$(RESET)\n"
	$(CXX) $(LDFLAGS) $(OBJECTS) -o $@

# Собираем все объектные файлы.
# Примечание 1: все заголовочные файлы переданы в качестве зависимости.
# Примечание 2: очевидно, сценарий "все файлы реализации зависят ото всех заголовочных файлов"
#               в случае обновления одного заголовочника будет приводить к пересборке всех объектных файлов.
#               Это обсудим на сдачах ДЗ.
build/%.o: src/%.cpp $(INCLUDES)
	@printf "$(BYELLOW)Building object file $(BCYAN)$@$(RESET)\n"
	@mkdir -p build
	$(CXX) -c $< $(CXXFLAGS) -o $@

#----------------------
# Вспомогательные цели
#----------------------

# Цель "запуск программы".
run: $(EXECUTABLE)
	@printf "$(BYELLOW)Running executable$(RESET)\n"
	@mkdir -p res
	@./$(EXECUTABLE)

# Цель "очистить результат сборки и исполнения".
clean:
	@printf "$(BYELLOW)Cleaning build and resource directories$(RESET)\n"
	rm -rf res
	rm -rf build

# Системная вспомогательная цель, содержащая список вспомогательных целей,
# в результате исполнения которых не появляется нового файла.
.PHONY: run clean default
